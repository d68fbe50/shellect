#!/usr/bin/env bash

# Variable explain:
# $y: the current argument
# $pos: the current position on argument y
# $y2: the current position on current screen position (invert color using SGR 33 7)
# $num: numbers of lines per argument
# $fin: bottom for printable area, depends on num
# $token: indicator for actions
# Dimension is adjustable by $top & $bottom

# Stolen from shfm
# Reference for color: https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_sequences
# Reference for vt100: https://vt100.net/docs/vt510-rm/contents.html
# Reference for escape sequence: https://github.com/dylanaraps/pure-sh-bible#escape-sequences
esc() {
    case $1 in
        # vt100 (IL is vt102) (DECTCEM is vt520)
	CUP)     printf '%s[%s;%sH' "$esc_c" "$2" "$3" ;; # cursor to LINES($2), COLUMNS($3)
        CUU)     printf '%s[%sA'    "$esc_c" "$2"      ;; # cursor up
        CUD)     printf '%s[%sB'    "$esc_c" "$2"      ;; # cursor down
        CUR)     printf '%s[%sC'    "$esc_c" "$2"      ;; # cursor right
	CUL)     printf '%s[%sD'    "$esc_c" "$2"      ;; # cursor left
	DECAWM)  printf '%s[?7%s'   "$esc_c" "$2"      ;; # (h: set; l: unset) line wrap
        DECRC)   printf '%s8'       "$esc_c"           ;; # cursor restore
        DECSC)   printf '%s7'       "$esc_c"           ;; # cursor save
        DECSTBM) printf '%s[%s;%sr' "$esc_c" "$2" "$3" ;; # scroll region
        DECSLRM) printf '%s[%s;%ss' "$esc_c" "$2" "$3" ;; # Set left and right margin
	DECTCEM) printf '%s[?25%s'  "$esc_c" "$2"      ;; # (h: show; l: hide) cursor visible
	ED[0-2]) printf '%s[%sJ'    "$esc_c" "${1#ED}" ;; # clear screen
        EL[0-2]) printf '%s[%sK'    "$esc_c" "${1#EL}" ;; # clear line
        IL)      printf '%s[%sL'    "$esc_c" "$2"      ;; # insert line
	SGR)     printf '%s[%s;%sm' "$esc_c" "$2" "$3" ;; # colors ($2); attribute ($3)
	    # Color list:
	    # 			FG	BG
	    # Black		30	40
	    # Red		31	41
	    # Green		32	42
	    # Yellow		33	43
	    # Blue		34	44
	    # Magenta		35	45
	    # Cyan		36	46
	    # White		37	47
	    # Bright Black 	90	100
	    # Bright Red	91	101
	    # Bright Green	92	102
	    # Bright Yellow	93	103
	    # Bright Blue	94	104
	    # Bright Magenta	95	105
	    # Bright Cyan	96	106
	    # Bright White	97	107

	    # Attribute list:
	    # Reset					0/''
	    # Bold					1
	    # Faint					2
	    # Italic					3
	    # Underline					4
	    # Slow blink				5
	    # Swap foreground and background colors.	7
	    # Hidden					8
	    # Strike-through				9

        # xterm (since 1988, supported widely)
	screen_alt) printf '%s[?1049%s' "$esc_c" "$2" ;; # (h: to; l: back from) alternate buffer
    esac
}

term_setup() {
    bottom=$((LINES - 2))				# space for bottom status_line
    top=3						# space for top status_line
    fin=$(( bottom - (bottom - (top - 1)) % num ))	# bottom for content printed

    stty=$(stty -g)
    stty -icanon -echo
    esc screen_alt h
    esc DECAWM l
    esc DECTCEM l
    esc ED2
    esc DECSTBM "$top" "$fin"
}

term_getsize() {
    # false-positive, behavior intentional, globbing is disabled.
    # shellcheck disable=2046
    {
        set -f -- $(stty size)
        set +f
    }

    LINES=$1 COLUMNS=$2
}

term_reset() {
    esc DECAWM h     >&2
    esc DECTCEM h    >&2
    esc ED2          >&2
    esc DECSTBM      >&2
    esc DECSLRM      >&2
    esc screen_alt l >&2
    stty "$stty"
}

redraw() {
    esc ED2

    status_line_top "$#"
    list_print "$@"
    status_line_bottom
}


list_print() {
    esc CUP "$top"

    i=1
    pos=$(( num * y - num + top ))
    end=$(( fin + 1 ))
    mid=$(( end / 4 < 5 ? 1 : end / 4 ))

    case $hist in
        2) # redraw after cmd run
	    shift "$((pos >= y2 ? (pos - y2) / num : 0))"
        ;;

        1) # redraw after go back
	    shift "$((pos >= fin ? (pos - y2) / num : 0))"
	    unset hist
        ;;

        *) # everything else
	    shift "$((y >= (end - top) / num ? y - (end - top) / num : 0 ))"
        ;;
    esac


    for file do

	case $(( num * i - num + top - end )) in
	    -*)
		list_format "$file"
		esc CUD
		i=$((i + 1))
		;;
	    0|*)
		break
		;;
	esac

    done

    esc CUP "$(( pos > y2 ? y2 : pos ))"
}

cur_assign(){ # assign $cur > 9
    shift "$1"
    cur=$1
}

old_save() {
    old_num=$num old_y=$y old_y2=$y2 old_pos=$pos old_cur=$cur old_format=$format old_msg=$msg old_ltype=$ltype
}

old_reset() {
    num=$old_num y=$old_y y2=$old_y2 pos=$old_pos cur=$old_cur format=$old_format msg=$old_msg ltype=$old_ltype
}

list_format() {
    esc EL0

    # overall display rule
    case $(( num * i - num + top )) in
	"$y2") esc CUR 2; esc SGR 35 1; printf '>'; esc SGR 33 1; esc CUR 2 ;;
	*)
	    esc CUR 5
	    esc SGR '' 2
	    ;;
    esac

    # content display format
    case "$format" in
	basename) printf %s "${1##*/}" ;;
	nldel) printf %s "${1%$nl}" ;;
	'') printf %s "$1" ;;
    esac

    esc SGR
    printf '\r'
}

arg_print() {
    offset=$1

    shift "$offset"

    case $offset in
        "$y") cur=$1 ;;
    esac

    arg_format "$1"
}


arg_format() {
    esc EL0

    # overall display rule
    case $offset in
	"$y") esc CUR 2; esc SGR 35 1; printf '>'; esc SGR 33 1; esc CUR 2 ;;
	*)
	    esc CUR 5
	    esc SGR '' 2
	    ;;
    esac

    # content display format
    case "$format" in
	basename) printf %s "${1##*/}" ;;
	nldel) printf %s "${1%$nl}" ;;
	'') printf %s "$1" ;;
    esac

    esc SGR
    printf '\r'
}

status_line_top () {
    esc DECSC
    esc CUP 1
    printf '%*s\r%s %s' "$COLUMNS" "" "($y/$1)" "$msg"
    esc DECRC
}

status_line_bottom () {
    esc DECSC
    esc CUP "$LINES"
    printf '%*s\r%s' "$COLUMNS" "" "$ltype"
    esc DECRC
}


term_move_up() {

    local fraction=$1; shift 1

    case $fraction in
        0) move=1 ;; # fraction=0, scroll up
	*) move=$(((end - top) / (fraction * num) > 2 ? (end - top) / (fraction * num) : 2)) ;; # fraction>0, page up
    esac

    case $y in
	-*|0|1) return ;;
    esac
    case $((y - 1 - move)) in
	-*|0) move=$((y - 1)) ;;
    esac

    y=$((y - move)) pos=$(( num * y - num + top ))

    for i in $(seq $((y + 1)) $((y + move))); do
	arg_print "$((y + move - i + y + 1))" "$@"
	case "$y2" in
	    $top) [ $num -gt 1 ] && esc CUU $((num - 1)); esc IL "$num" ;;
	    *) esc CUU "$((num * 2 - 1))"; y2=$(( y2 > top ? y2 - num : top )) ;;
	esac
    done
    arg_print "$y" "$@"

    # Restore cursor to match y2
    [ $num -gt 1 ] && esc CUU "$((num - 1))"
    status_line_top "$#"
    status_line_bottom
}

term_move_down() {

    local fraction=$1; shift 1

    case $fraction in
        0) move=1 ;; # fraction=0, scroll down
	*) move=$(((end - top) / (fraction * num) > 2 ? (end - top) / (fraction * num) : 2)) ;; # fraction>0, page down
    esac

    case $(( y - $# + move )) in
	[1-9]*) move=$(($# - y)) ;;
    esac

    y=$(( y + move ))
    pos=$(( num * y - num + top ))
    y2=$(( y2 + num * move < fin - (num - 1) ? y2 + num * move : fin - (num - 1) ))


    for i in $(seq $((y - move)) $((y - 1))); do
	arg_print "$i" "$@"
	printf '\n'
    done
    arg_print "$y" "$@"

    [ $num -gt 1 ] && esc CUU "$((num - 1))"

    status_line_top "$#"
    status_line_bottom
}

prompt() {
    esc DECSC
    esc CUP "$LINES"
    printf %s "$1"
    esc DECTCEM h
    esc EL0

    case $2 in
        r)
	    stty -cread icanon echo 1>/dev/null 2>&1
	    read -r ans ||:
	    stty -icanon -echo
	    ;;
    esac

    esc DECRC
    esc DECTCEM l
}

search() {
    local content="$1"
    local IFS="$2"
    local str="$3"
    local filter posnum lower_content lower_str i j n

    case $case_insense in
	1) # case-insensitive filter
	    # lowercase both content and str
	    lower_content=$(printf '%s' "$content" | tr '[:upper:]' '[:lower:]')
	    lower_str=$(printf '%s' "$str" | tr '[:upper:]' '[:lower:]')

	    # First run: match lowercase and record the number of positional parameter
	    i=1
	    set -- $lower_content
	    for line do
		case $line in
		    *$lower_str*) posnum="$posnum $i" ;;
		esac
		i=$((i+1))
	    done
	    posnum=${posnum#* } # delete first space

	    # Second run: match the item based on that list above
	    set -- $content

	    j=1
	    for line do
		n=${posnum%% *} # first line number
		case $j in
		    "$n")
			filter="$filter$IFS$line"
			posnum=${posnum#* } # delete first numer
			;;
		esac
		j=$((j+1))
	    done

	    ;;
	*) # case-sensitive filter
	    set -- $content
	    for line do
		case $line in
		    *$str*) filter="$filter$IFS$line" ;;
		esac
	    done
	    ;;
    esac

    filt_out=${filter#*$IFS}
}

key() {
    while key=$(dd ibs=1 count=1 2>/dev/null); do
	case $key${esc:=0} in
	    "$ctrl_u"?|~5)
		term_move_up 4 "$@"
	    ;;

	    "$ctrl_f"?|~6)
		term_move_down 4 "$@"
	    ;;

	    k?|A2|"$ctrl_p"?)
		term_move_up 0 "$@"
	    ;;

            j?|B2|"$ctrl_n"?)
		term_move_down 0 "$@"
	    ;;

            g?|H2|"$ctrl_a"?)
                case $y in
                    1) continue ;;
                esac

                y=1 y2=$top cur=$1
		redraw "$@"
            ;;

            G?|F2|"$ctrl_e"?)
		y=$# pos=$(( num * y - num + top ))
		y2=$(( pos < fin - (num - 1) ? pos : fin - (num - 1) ))
		cur_assign "$y" "$@"
		redraw "$@"
            ;;

            l?|C2|"$esc") # ARROW RIGHT
		term_reset
		return
            ;;

            h?|D2|"$bs_char"?) # ARROW LEFT

		[ -n "$search_ind" ] || [ -n "$help_ind" ] &&
		    {
			unset search_ind help_ind
			IFS=$ifs
			set -- $content
			unset IFS
			hist=1
			old_reset "$@"
			redraw "$@"
		    }
            ;;

            /?)
                prompt / r
		search "$content" "$ifs" "$ans"
		local search_ind=1
		IFS=$ifs
		set -- $filt_out
		unset IFS
                case $# in
                    0)
			num=1
			set -- 'no result'
			;;
                esac

		old_save "$@"
		y=1 y2=$top cur=$1 ltype="Search mode" msg="Search by *$ans*"
                redraw "$@"
            ;;

            \??)
		local help_ind=1
		set -- 'k/↑/Ctrl-p - up' \
		       'j/↓/Ctrl-n - down' \
		       'l/→ - right' \
		       'h/← - left' \
		       'Ctrl-f/PageDown - PageDown' \
		       'Ctrl-u/PageUp - PageUp' \
		       'g/Home/Ctrl-a - go to top' \
		       'G/End/Ctrl-e - go to bottom' \
		       '/ - search' \
		       '? - show keybinds' \
		       'q - quit'

		old_save "$@"
		unset format
                num=1 y=1 y2=$top cur=$1 ltype= msg=keybinds token='?'
                redraw "$@"
            ;;

            q?)
		term_reset
		exit 0
		;;
            "$esc_c"*) esc=1 ;;
                 '[1') esc=2 ;;
		   5?) esc=5 ;; # PageUp
		   6?) esc=6 ;; # PageDown
                    *) esc=0 ;;
	esac
    done
}

usage () {
cat << 	EOF
Usage:

shmenu [OPTIONS] ([ARGS])

  -h,			Show help options
  -i,			Set case-insensitive search
  -n=[num],		Set numbers of line per entry
  -d=[IFS],		Set IFS
  -c=[content],		Set content to display
  -f=[format],		Set the format to print out content
  -t=[msg],		Set top status bar message
  -b=[msg],		Set bottom status bar message

format detail:
  nldel			delete last nl, equiv to "\${1%\$nl}"
  basename		only print basename, equiv to "\${1##*/}" ;;

  if unset or empty, then equiv to "\$1"

EOF
}

main() {

    trap 'term_reset' INT
    trap 'term_getsize; term_setup; y=1 y2=$top; redraw "$@"' WINCH

    IFS=${ifs:=$nl}
    set -- $content
    unset IFS

    term_getsize
    term_setup
    y=1 y2=$top cur=$1
    redraw "$@"

    key "$@"

}

nl='
'
tab='	'

# special key setting
esc_c=$(printf '\033')
bs_char=$(printf '\177')
ctrl_f=$(printf '\006')
ctrl_u=$(printf '\025')
ctrl_n=$(printf '\016')
ctrl_p=$(printf '\020')
ctrl_a=$(printf '\001')
ctrl_e=$(printf '\005')
tilda=$(printf '\176')

while getopts "t:b:n:d:s:c:f:hi" result; do
    case "${result}" in
        n) num=${OPTARG} ;;
        d) ifs=${OPTARG} ;;
        c) content=${OPTARG} ;;
        f) format=${OPTARG} ;;
	i) case_insense=1 ;;
	t) msg="${OPTARG}" ;;
	b) ltype="${OPTARG}" ;;
	h) usage && exit 0 ;;
    esac
done

case "$content" in
    '') content=$(cat -u -) ;; # Accept pipe stdin
esac

num=${num:=1} # num=1 if unset
main "$@" <&2 >/dev/tty # why it works, I don't know.
printf '%s' "$cur" >&1
